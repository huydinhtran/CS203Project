#ifndef PREFETCHER_H
#define PREFETCHER_H

#include <sys/types.h>
#include "mem-sim.h"
#include "cache.h"
#include "memQueue.h"
#include "CPU.h"

struct Request;

class Prefetcher {
  private:
	bool _ready;
	Request _nextReq;

	//tag – the tag corresponding to the address of the memory instruction
	u_int32_t tag;
	//prev-addr – the last address referenced by the corresponding instruction
	u_int32_t prev_addr;
	//stride – the difference between the last two addresses that were generated by the corresponding PC (can be negative)
	u_int32_t stride;
	// State: 0 = initial, 1 = transient, 2 = steady, 3 = no-prediction
	u_int32_t state;

  public:
  	Prefetcher();
	// should return true if a request is ready for this cycle
	// Value returned indicates whether there is a request waiting from the prefetcher. 
	// This function is used as a gate before getRequest() is called.
	bool hasRequest(u_int32_t cycle);

	// request a desired address be brought in 
	// Returns a request to be sent to the L2 cache. 
	//Only the addr field of the Request struct will be used.
	Request getRequest(u_int32_t cycle);

	// this function is called whenever the last prefetcher request was successfully sent to the L2
	void completeRequest(u_int32_t cycle);

	/*
	* This function is called whenever the CPU references memory.
	* Note that only the addr, pc, load, issuedAt, and HitL1 should be considered valid data
	This function is called after a CPU request is handled. 
	The request gives the addr, pc, cycle it was issued, and whether it was a hit or miss in the D cache.
	*/
	void cpuRequest(Request req); 

	//return the tag of the address
	u_int32_t getTag(u_int32_t addr);

	//find the index of the tag in the RPT table
	u_int32_t findTag(u_int32_t addr);

};

#endif
