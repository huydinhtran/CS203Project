// Huy Dinh Tran
// ID:862325308


#ifndef PREFETCHER_H
#define PREFETCHER_H

#include <sys/types.h>
#include "mem-sim.h"
#include "cache.h"
#include "memQueue.h"
#include "CPU.h"

struct Request;

class Prefetcher {
  private:
	bool _ready;
	Request _nextReq;

	//tag – the tag corresponding to the address of the memory instruction
	u_int32_t tag;
	//prev-addr – the last address referenced by the corresponding instruction
	u_int32_t prev_addr;
	//stride – the difference between the last two addresses that were generated by the corresponding PC (can be negative)
	u_int32_t stride;
	// State: 0 = initial, 1 = transient, 2 = steady, 3 = no-prediction
	u_int32_t state;

  public:
  	Prefetcher();
	// Value returned indicates whether there is a request waiting from the prefetcher. This function is used as a gate before getRequest() is called.
	bool hasRequest(u_int32_t cycle);

	// Returns a request to be sent to the L2 cache. Only the addr field of the Request struct will be used.
	Request getRequest(u_int32_t cycle);

	// This function is called as soon as the last request is successfully sent to the L2 cache.
	void completeRequest(u_int32_t cycle);

	// This function is called after a CPU request is handled. The request gives the addr, pc, cycle it was issued, and whether it was a hit or miss in the D cache.
	void cpuRequest(Request req); 

	//return the tag of the address
	u_int32_t getTag(u_int32_t addr);

	//find the index of the tag in the RPT table
	u_int32_t findTag(u_int32_t addr);

};

#endif
